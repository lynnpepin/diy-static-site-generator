<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>You can sort in linear time!</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="../style.css" />
  <!--[if lt IE 9]>
    <script src="/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <a href="/index.html">
  <h1 id="blog-title">
  lynn pepin //<code>lynndotpy</code>
  </h1>
  <p></a></p>
  <p id="header">
  <a href="/index.html">Index</a> | <a href="/about.html">About</a> | <a
  href="/projects.html">Projects</a>
  </p>

<!-- favicons, code ty https://realfavicongenerator.net/ -->
<link rel="apple-touch-icon" sizes="180x180" href="favicon_package/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="favicon_package/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="favicon_package/favicon-16x16.png">
<link rel="manifest" href="favicon_package/site.webmanifest">
<link rel="mask-icon" href="favicon_package/safari-pinned-tab.svg" color="#5bbad5"> 
<link rel="shortcut icon" href="favicon_package/favicon.ico">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">

</head>
<body>
<hr />

<time datetime=2022-1-7>
<p class="date">2022-1-7</p>

<header>
<h1 class="title">You can sort in linear time!</h1>

</header>

<p><strong>TLDR:</strong> Yes-- you can sort numbers in linear time.
Yes, including floats! The proof that you can sort in O(n log n) time is
still true, but that assumes you're sorting on the infinite set of real
numbers (or integers.) We can sort in linear time because we work with
finite sets: Floats and ints. The algorithm is very simple, and is
called counting sort (or bin sort or radix sort.)</p>
<p>To address common suspicions:</p>
<ul>
<li>Counting sort is not a randomized algorithm, it always outputs the
correct solution.</li>
<li>Counting sort is not a parallelized algorithm. (And you can't use
parallelism to speed past a worst-case big-O run time anyway!)</li>
<li>Counting sort is not an amortized algorithm. It is truly O(n), not
'expected' or 'amortized' O(n).</li>
<li>Counting sort is technically Θ(n), that is, the worst and best case
running time is linear.</li>
<li>This can be used in the real world.</li>
<li>However, it is not an in-place sorting algorithm.</li>
</ul>
<h1 id="ok-how-does-counting-sort-work">ok, how does counting sort
work?</h1>
<p>The idea of the algorithm is that you count how many times a number
appears in a list.</p>
<ol type="1">
<li>Get input a list <code>L</code> of numbers from some finite set
<code>K</code>.</li>
<li>Instantiate a dictionary <code>S</code> with zeros, with one element
for each item in <code>K</code>.</li>
<li>For each item in <code>L</code>, increment the corresponding element
in <code>S</code> by one.</li>
<li>Then, for each item <code>k in K</code>, output <code>k</code> a
total of <code>L[k]</code> times each.</li>
</ol>
<p>Here's a simple implementation in Python.</p>
<pre><code>
set_of_numbers_to_sort = list(range(0, 256)) 
counted_numbers = {kk : 0 for kk in set_of_numbers_to_sort}

numbers_in = input(&quot;Enter values in [0, 255] separated by space:\n&quot;)
numbers_in = numbers_in.split(&#39; &#39;)
for number in numbers_in:
    counted_numbers[int(number)] += 1

for number in set_of_numbers_to_sort:
    for _ in range(counted_numbers[number]):
        print(number)</code></pre>
<blockquote>
<p>Note: This example implementation uses a dict for clarity and
generality, so it's technically not guaranteed Θ(k+n)!</p>
</blockquote>
<h1 id="a-real-world-example-of-counting-sort-on-integers">a real-world
example of counting sort on integers</h1>
<blockquote>
<p><strong>TLDR:</strong> Imagine you have a 1-billion letter corpus.
Here, n = 1000000000 and k=26. So, the O(n+k) counting-sort algorithm
will be faster than the conventional O(n log n) sorting algorithms.</p>
</blockquote>
<p>So, counting-sort can be used in the real world when you have to sort
a very large list of values that belong to a relatively small set. This
could be 8-bit or 16-bit floats or ints, or even smaller sets like the
26-character alphabet.</p>
<p>For this example, let's say you wanted to see the frequency of
letters in a 1-billion-character English text. You can count each
character to see how many of the 26 letters appear. This is equivalent
to sorting.</p>
<ol type="1">
<li><p>Get an input <code>L</code> which is the 1-billion-character
text, where <code>K = {A, B, C, ..., X, Y, Z}</code>.</p></li>
<li><p>Instantiate the dict
<code>S = {A : 0, B : 0, C : 0, ..., Z : 0}</code>.</p></li>
<li><p>For each character in in <code>L</code>, increase the
corresponding element in <code>S</code> by one.</p>
<ul>
<li><p>E.g. For 'C', we get
<code>S = {A : 0, B : 0, C : 1, ..., Z : 0}</code>.</p></li>
<li><p>E.g. And then if we get an A for the next, we get
<code>S = {A : 1, B : 0, C : 1, ... }</code>.</p></li>
</ul></li>
<li><p>And then print each element from S.</p></li>
</ol>
<p>This algorithm is <code>O(|L| + |K|)</code>. This is also written as
<code>O(n + k)</code>, where <code>k</code> is the size of the set we
want to sort.</p>
<h1 id="tell-me-more-about-sorting">tell me more about sorting</h1>
<p>So far we assume you need to perfectly sort an arbitrary list of
values.</p>
<p>You can speed things up if:</p>
<ol type="1">
<li>You know something about the distribution of values, or</li>
<li>You know something about the application of the sort.</li>
</ol>
<p>If you're sorting floats, but you know most of your values are NaN or
0.0, you can use counting-sort for NaN and 0.0, and use a traditional
sort on the rest.</p>
<p>What if your sort doesn't need to be super accurate? Say, for a very
niche case, you want to sort a histogram on the logarithm of some list
of values. Then, you can sort your float64s on the 11-bit exponent,
which means k = 2^11 = 2048, which means you can use counting-sort!</p>
<h1 id="okay-so-whats-the-take-away-here">okay so what's the take-away
here</h1>
<p>Well, I've only ever written sorting algorithms in job-interviews and
university exams. I'm happy to say some of them were linear, and I'm
very happy to say I've never had to performance-engineer things like
this.</p>
<p>There is a small rift between the model of computing used in
computer-science and the actual computers we use. The space between that
rift is really cool, and leads to fun facts like "you can sort in linear
time".</p>
<p>Remember to like, comment, and subscribe* for more fun blog-posts,
such as:</p>
<ol type="1">
<li>"Sorry Amdahl, but parallel computing DOES give you superlinear
speedup"</li>
<li>"P and NP don't matter if you're not in aerospace because randomized
algorithms are magic"</li>
<li>"Moore's Law isn't exponential, and it's not sigmoidal either. It's
a distribution, I'm afraid we're nearing it's peak, and I'm frightened
about the world beyond it: A Short Treatise on Why 640KB ought to be
enough for anyone because you won't have a choice in 200 years"</li>
</ol>
<hr />
<p>*This is a joke, I'm not actually writing these blogposts, and you
can't like, comment, or subscribe.</p>
<hr />
<p id="footer">
<a href="https://gitlab.com/lynnpepin/">lynndotpy</a> since 2020 | <a
href="https://creativecommons.org/licenses/by-nc-sa/4.0/">cc
by-nc-sa</a> unless specified | <a
href="https://mastodon.social/@lynndotpy">mastodon</a> | <a
href="https://twitter.com/lynndotpy">twitter</a> | <a
href="https://gitlab.com/lynnpepin/diy-static-site-generator">gitlab</a>
| <a
href="https://github.com/lynnpepin/diy-static-site-generator">github</a>
</p>
</body>
</html>
